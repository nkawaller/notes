
<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap"
        rel="stylesheet" />
    <link rel="stylesheet" href="./static/output.css" />
    <title>Markdown Blog</title>
</head>

<body class="flex min-h-screen flex-col text-base font-medium text-zinc-900 md:text-lg">
    
    <div class="p-4">
        <div class="container mx-auto flex items-center justify-between">
            
            <div class="float-left">
                <a href="/" class="text-8xl">N</a>
            </div>

            
            <div class="float-right">
                <a href="https://github.com/nkawaller" class="ml-4">Open Source</a>
                <a href="/root.html" class="ml-4">Notes</a>
                <a href="#" class="ml-4">About</a>
            </div>
        </div>
    </div>

    
    <article class="prose prose-zinc prose-base md:prose-lg prose-headings:font-semibold mx-auto mt-16 flex-1 p-4">
        
        <div>
            <aside class="mb-3.5">
                <span class="text-xs text-zinc-500">
                    Last updated 2024-03-25
                </span>
            </aside>
            <h1>Ownership in Rust</h1>

<p>Ownership is what allows rust to make memory safety guarantees without needing
a garbage collector.</p>

<h2>Ownership Defined</h2>

<ul>
<li>a set of rules</li>
<li>that defines</li>
<li>how a Rust program manages memory</li>
</ul>

<h2>Basics</h2>

<p>All programs (in any language) have to manage they way they use memory</p>

<ul>
<li>python uses a garbage collector</li>
<li>in c you must explicitly allocate and free memory</li>
<li>rust uses ownership rules</li>
</ul>

<h3>Stack and Heap Review</h3>

<p>All data stored on the stack must have a known, fixed size. Data with an
unknown size at compile time must be stored on the heap. The heap is less
organized——here&rsquo;s how it works</p>

<ul>
<li>request a certain amount of space</li>
<li>the memory allocator finds an empty spot that&rsquo;s big enough</li>
<li>and returns a pointer (the address of that location)</li>
</ul>

<p>Because this pointer is a known, fixed size, it can be stored on the stack. If
you want to access the actual data, you must follow the pointer. This is a
slower process.</p>

<p>When your code calls a function, the values passed into the function and the
function&rsquo;s local variables get pushed onto the stack. When the function is over
those values get popped off.</p>

<p>The main purpose of ownership is to manage heap data.</p>

<h2>The Rules</h2>

<ul>
<li>Each value in Rust has an owner</li>
<li>There can only be one owner at a time</li>
<li>When the owner goes out of scope, the value will be dropped</li>
</ul>

<h2>The String Type</h2>

<p>All the previous types we covered were of a known size——they can be stored on
the stack. The String type is more complex and requires use of the heap.</p>

<p>When we call <code>String::from()</code> it requests the memory it needs. Now in most
garbage collected languages, the GC keeps track of and cleans up memory that
isn&rsquo;t being used anymore. In rust, the memory is automatically returned once
the variable that owns it goes out of scope. When a variable goes out of scope,
Rust calls a special fn called <code>drop</code>.</p>

<h3>Two Examples</h3>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>let x = 5;
</span></span><span style="display:flex;"><span>let y = x;
</span></span></code></pre>
<p>In this code, we bind the value <code>5</code> to <code>x</code>; then make a copy of the value in
<code>x</code> and bind it to <code>y</code>. Integers are a simple type (pushed onto the stack). But
it&rsquo;s different with the <code>String</code> type:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>let s1 = String::from(&#34;hello&#34;);
</span></span><span style="display:flex;"><span>let s2 = s1;
</span></span></code></pre>
<p>This doesn&rsquo;t work the same way. Instead, what we get is a pointer to store on
the stack; and it points us to memory on the heap. This pointer is made up of
three parts</p>

<ul>
<li>ptr: address of the heap location</li>
<li>len: how much memory (in bytes) the contents of the String is currently using</li>
<li>capacity: total amount the String has received from the allocator</li>
</ul>

<p>In the above code example, s2 is a copied pointer to the same data on the heap.
Also, once we assign s2, Rust considers s1 no loger valid. Rust calls this a
<em>move.</em> You could say tht s1 was <em>moved</em> to s2.</p>

<blockquote>
<p>other languages call this copying of the pointer only a shallow copy. It&rsquo;s
only called a move in rust because of the extra invalidation step. Also, rust
never automatically makes deep copies of your data</p>
</blockquote>

<h3>Clone</h3>

<p>If you <em>do</em> want to make a deep copy of the heap data, (instead of a shallow
copy of just the stack data), you can call <code>clone().</code> This is a more expensive
operation.</p>

<h3>Copy</h3>

<p>Fixed size types such as integers get a special annotation called <code>Copy</code> and
the following code would work:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>let x = 5;
</span></span><span style="display:flex;"><span>let y = x;
</span></span><span style="display:flex;"><span>println!(&#34;{x}&#34;);
</span></span></code></pre>
<p>Here, x doesn&rsquo;t get invalidated.</p>

<h2>Ownership and Functions</h2>

<p>The mechanics of passing a value to a function are similar to those when
assigning a variable.</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>let s = String::from(&#34;hello&#34;);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>takes_ownership(s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>let x = 5;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>makes_copy(x);
</span></span><span style="display:flex;"><span>
</span></span></code></pre>
<h2>Return Values and Scope</h2>

<p>A function can take ownership and transfer ownership when it returns the value.
However all this taking and returning ownership all the time can get a bit
tedious. What if we want to let a function use a value but not take ownership?
Lucky for us, Rust enables this through the use of references.</p>

<h2>References</h2>

<p>A reference is like a pointer——it&rsquo;s an address we can follow to access the data
stored at that address. However, unlike a pointer, a reference is guaranteed to
point to a valid value of a particular type for the life of that reference.</p>

<p>Here&rsquo;s how you use them:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>fn calculate_length(s: &amp;String) -&gt; usize {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>calculate_length(&amp;s1);
</span></span></code></pre>
<p>References allow you to refer to some value without taking ownership of it.</p>

<p>Just as in C, <code>*</code> is the dereference operator.</p>

<p>References are immutable by default just like variables. But you can change
them by making the references mutable:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>&amp;mut
</span></span></code></pre>
<p><em>Important:</em> if a reference is mutable, you can&rsquo;t have any other references to
that value; only one at a time. This prevents multiple references to the same
data at the same time which can lead to <em>data races.</em></p>

<p>Data Race:</p>

<ul>
<li>two or more pointers access the same data at the same time</li>
<li>at least one of the pointers is being used to write to the data</li>
<li>there&rsquo;s no mechanism being used to synchronize access to the data</li>
</ul>

<p>Also, you can&rsquo;t have both immutable and mutable references to the same data at
the same time. You <em>can</em> however have many immutable references to the same
data at the same time.</p>

<h3>Dangling References</h3>

<p>It&rsquo;s easy to create a dangling pointer by accident:</p>

<ul>
<li>a pointer references a location in memory</li>
<li>that memory is given to someone else (through <code>free()</code>)</li>
<li>the pointer still points to that location (but the data has changed!)</li>
</ul>

<h2>The Slice Type</h2>

<p>Slices let you reference a contiguous sequence of elements in a collection
rather than the whole collection. It&rsquo;s a reference to <em>part</em> of a string. The
way you indicate this type in function signatures is like this:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>&amp;str
</span></span></code></pre>
<h2>Structs</h2>

<p>Structs give you a way to group data (you can do this with tuples). Think of a
struct as an object&rsquo;s data attributes in OOP. They (along with enums) are the
building blocks for creating new types in your program.</p>

<p>They&rsquo;re like tuples in that both hold multiple related values. But with structs
you name each piece of data. This makes them more flexible because you don&rsquo;t
need to rely on the order of the data.</p>

<p>Say we had a <code>User</code> struct; we could define a <code>build_user</code> function that would
instantiate a new user.</p>

<blockquote>
<p>When I see the syntax for tuple structs: <code>struct Color(i32, i32, i32)</code> I think
of building types from the ground up. In this case, we&rsquo;re building a type that
is built upon the i32 primitive type.</p>
</blockquote>

<h3>Example Program</h3>

<p>In the calculate area of rectangle program, we have a function that performs
the calculation:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>fn area(width: u32, height: u32) -&gt; u32 {
</span></span></code></pre>
<p>The problem with it is it&rsquo;s not as clear as it could be. It&rsquo;s supposed to find
the area of one rectangle, but this function takes in two parameters. And it&rsquo;s
not clear that the parameters are related.</p>

<p>We could refactor with tuples, and that would be better in a way. But because
tuples don&rsquo;t name their arguments, it&rsquo;s still not entirely clear what&rsquo;s going
on.</p>

<p><em>Structs add meaning by labeling the data.</em> Being able to pass one &ldquo;Rectangle&rdquo;
into the area function, and then being able to label what the two numbers mean
(width and height) makes the program a lot clearer——the function signature now
says exactly what you mean.</p>

<h3>Traits</h3>

<p>Ever see this error???</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>error[E0277]: <span style="color:#fe8019">`</span>Rectangle<span style="color:#fe8019">`</span> doesn<span style="color:#b8bb26"></span><span style="color:#b8bb26">&#39;</span><span style="color:#b8bb26">t imple
</span></span></span></code></pre>
<p>How can we print our Rectangle all at once?</p>

<p>One thing we can do is add this to our struct:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>#[derive(Debug)]
</span></span></code></pre>
<h3>Methods</h3>

<p>Methods are similar in many ways to functions. You declare them with the <code>fn</code>
keyword. However they are defined within the context of a struct, and their
first parameter is always <code>self.</code></p>

<p>We define them within implementation blocks (<code>impl</code>), and everything within the
block will be associated with that struct. (All functions within an impl block
are called <em>associated functions.</em></p>

<p>The main reason to use methods over functions is for organization. It&rsquo;s easier
if everythin that can act on a Rectangle is within one <code>impl</code> block instead of
scattered all over the place.</p>

<p>You can define a method that has the same name as one of the fields on the
struct——and often these methods just return the value that&rsquo;s in the field with
the same name. These methods are often called <em>getters.</em> The advantage to using
getters is if you make the field private and the method public, then you enable
read-only access to that field as part of the type&rsquo;s public API.</p>

<p>We can have associated functions that don&rsquo;t have self as their first parameter
and therefore are not methods. This pattern is often used for constructors that
return a new instance of the struct. The convention is to name these <code>new().</code>
To call this function we use the <code>::</code> syntax.</p>

<h2>Enums</h2>

<p>While structs give you a way of grouping together related fields and data,
enums give you a way of saying a value is one of a possible set of values. An
example of this is with IP addresses. Currently all IPs are either version 4 or
version 6. So we can enumerate all possible variants:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>enum IpAddrKind {
</span></span><span style="display:flex;"><span>    V4,
</span></span><span style="display:flex;"><span>    V6,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<p>Now we have a custom data type we can use elsewhere in our code. And you can
put data directly into enum variants:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>enum IpAddrKind {
</span></span><span style="display:flex;"><span>    V4(String),
</span></span><span style="display:flex;"><span>    V6(String),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<p>You can define methods on enums too! Just put it in an <code>impl</code> block.</p>

<h3>Option</h3>

<p>This enum provided by the standard library encodes the scenario where a value
could be something, or it could be nothing.</p>

<p>Many languages implement the concept of null——NULL is a value that represents
the absence of a value. Rust doesn&rsquo;t do this, but it does have the Option enum
which allows you to encode this concept:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>enum Option&lt;T&gt; {
</span></span><span style="display:flex;"><span>    None,
</span></span><span style="display:flex;"><span>    Some(T),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<blockquote>
<p><T> is the generic type parameter.</p>
</blockquote>

<p>In order to have a value that can possibly be null, you must explicitly opt in
by making the type of that value <code>Option&lt;T&gt;</code>. Then when you use that value you
are required to explicitly handle the case when the value is null.</p>

<h3>Control Flow with Match</h3>

<p>Match seems very similar to an if statement, but there&rsquo;s one big difference. An
if statement needs a boolean conditon to be met——<em>but with match the condition
can be any type</em>.</p>

<p>match is very useful with Option<T> —— we can create an arm to execute if there
is no value (None), and another to execute when there is a value.</p>

<p>Rust devs combine match with enums often. A common pattern is match against an
enum; bind a variable to the data inside; execute code based on it.</p>

<p>Use the underscore to match &ldquo;all other cases&rdquo;; combine that with an empty tuple
to &ldquo;do nothing in all the other cases:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>_ =&gt; ()
</span></span></code></pre>
<h4>if let</h4>

<p>this expression behaves the same way as <code>match</code>. Use in the case where you&rsquo;re
trying to match one pattern, and ignore all other values. It&rsquo;s like match
shorthand.</p>

<h2>Packages and Crates</h2>

<p>rustc == the rust compiler
A <em>crate</em> is the smallest amount of code the compiler considers at a time. And
crates can contain modules. <em>Library crates</em> don&rsquo;t contain a main() function
and don&rsquo;t compile to an executable. Rust devs often refer to these when they
say &ldquo;crate&rdquo;——you could also say &ldquo;library.&rdquo;</p>

<p>A <em>package</em> is a bundle of one or more crates that provides a set of
functionality.</p>

<h3>Steps in creating a package</h3>

<ol>
<li>run <code>cargo new my-project</code></li>
<li>Cargo creates a few things, including a Cargo.toml file——this file is what
gives us a package.</li>
<li>Cargo follows the convention that <code>src/main.rs</code> is the crate root of a
binary crate. If your package is just a library crate, your crate root will
be <code>src/lib.rs</code> instead. (You can have both too!).</li>
</ol>

<h3>Paths, Scope, Privacy</h3>

<p>The <code>use</code> keyword brings a path into scope.
The <code>pub</code> keyword makes items public.</p>

<h3>Modules</h3>

<p><em>Modules</em> let us organize code within a crate for readability and easy reuse.
Code within a module is private by default.</p>

<p>By using modules you can group related definitions together. Programmers using
this code can navigate the codebase based on these groups, and when they need
to add new functionality, they know where the code should go.</p>

<p>The module tree looks a lot like a filesystem directory tree. You can organize
your code in this same way.</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>crate
</span></span><span style="display:flex;"><span> └── front_of_house
</span></span><span style="display:flex;"><span>     ├── hosting
</span></span><span style="display:flex;"><span>     │   ├── add_to_waitlist
</span></span><span style="display:flex;"><span>     │   └── seat_at_table
</span></span><span style="display:flex;"><span>     └── serving
</span></span><span style="display:flex;"><span>         ├── take_order
</span></span><span style="display:flex;"><span>         ├── serve_order
</span></span><span style="display:flex;"><span>         └── take_payment
</span></span></code></pre>
<h3>Referring to Items in the Module Tree</h3>

<p>Two ways:</p>

<ul>
<li>absolute path (starts with <code>crate</code> keyword)</li>
<li>relative path (uses <code>self</code> or <code>super</code>)</li>
</ul>

<h3>The <code>use</code> keyword</h3>

<p><code>use</code> provides a shortcut to bring paths into scope.</p>

<h4>The Standard Library</h4>

<p>The standard library ships with the rust language, so you don&rsquo;t need to add it
to Cargo.toml, but you do need to use the <code>use</code> keyword to access it.</p>

<h4>Nested Paths</h4>

<p>If you&rsquo;re brining a bunch of items in from the same crate or module, it&rsquo;s more
concise to use this syntax:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>use std::{cmp::Ordering, io};
</span></span></code></pre>
<p>Use the glob operator to bring in all public items:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>use std::collections::*;
</span></span></code></pre>
<p>This is most often used when testing, to bring everything into the tests module</p>

<h3>Separating Modules into Different Files</h3>

<p>As modules get large, you might want to move their definitions to a separate
file for better organization.</p>

<h2>Collections</h2>

<p>Unlike array and tuple types, the data these collections point to is stored on
the heap. The three you&rsquo;ll use most often are:</p>

<ul>
<li>vector (resizable array)</li>
<li>string (collection of characters)</li>
<li>hash map (kev value store)</li>
</ul>

<h3>Vectors</h3>

<p>Create a new vector like this:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>let v: Vec&lt;i32&gt; = Vec::new();
</span></span></code></pre>
<p>Here, we&rsquo;re adding the type annotation because it&rsquo;s initialized without any
values, and Rust can&rsquo;t infer what we intend to use it for. If you do initialize
it with values, you don&rsquo;t need the type annotation:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>let v = vec![1, 2, 3];
</span></span></code></pre>
<p>Vectors can only store elements of the same type. If you need to store a
collection of different typed items, use an enum.</p>

<h3>Strings</h3>

<p>Strings are stored as a collection of bytes.</p>

<p>We should quickly remind ourselves that string slices (<code>str</code>, <code>&amp;str</code>) are also
referred to as strings, but here we&rsquo;re talking about a growable, mutable, owned
object.</p>

<p>String literals are slices:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>let data = &#34;hello&#34;;
</span></span></code></pre>
<p>To make it a String type we can use <code>.to_string()</code></p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>let s = data.to_string();
</span></span></code></pre>
<p>You can concatenate strings using the <code>+</code> operator, but that can get a bit
unwieldly. As things get more complex, use the <code>format!</code> macro:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>let s = format!(&#34;{s1}-{s2}-{s3}&#34;);
</span></span></code></pre>
<p>Note! Rust doesn&rsquo;t support accesing Strings by index; no s[0]. This is a
complex topic - look into it more.</p>

<h3>Hash Maps</h3>

<p>They use the SipHash hash function.</p>

<h2>Panic! and Error Handling</h2>

<p>In C if you try to access a array past it&rsquo;s alloted memory you get unspecified
behavior——this is called a <em>buffer overread</em> and can lead to security issues.
Rust prevents this by throwing a panic! instead.</p>

<p>A <em>backtrace</em> is a list of all the functions that have been called to get to
the failure point.</p>

<h3>Result</h3>

<p>Use the Result enum for errors that aren&rsquo;t so serious that we need to unwind
all the way back out. It has two variants, <code>Ok</code> and <code>Err</code>——we can use a match
expression to handle each case. And we can drill deeper and handle different
error cases using match as well. Use ErrorKind for this.</p>

<p>Match expressions are primitive——one higher level way to handle this that is a
bit more readable is to use closures.</p>

<p>Other ways to do this are using <code>unwrap</code> or <code>expect</code>. Expect is the common
convention in production-quality code among Rust devs.</p>

<p>There&rsquo;s also the <code>?</code> operator we can use.</p>

<h3>When to use panic! or Result</h3>

<p>In prototyping and testing start off with unwrap and expect——these make it
clear where your failures are, and you can always go back to them when you&rsquo;re
ready to make your code more robust.</p>

<p>In general, use panic! when your code could end up in a bad state:</p>

<ul>
<li>invalid or missing values are passes to your code</li>
<li>something unexpected as opposed to something that happens occasionally</li>
<li>when the code further down the line depends on not being in a bad state</li>
</ul>

<p>However if a failure is expected, it&rsquo;s more appropriate to return a Result.</p>

<h2>Generic Types, Traits, and Lifetimes</h2>

<p>Generics are a tool for handling teh duplication of concepts (controlling
complexity via abstraction?)</p>

<p>Generics:</p>

<ul>
<li>replace specific types with&hellip;</li>
<li>a placeholder that represents multiple types</li>
</ul>

<h3>Basic way to avoid duplication</h3>

<ul>
<li>Write code to fine the largets number in a list</li>
<li>Then say you want to find the largest number in a different list</li>
<li>You &ldquo;could&rdquo; copy and paste the code</li>
<li>But a better way would be to

<ul>
<li>create an abstraction</li>
<li>by defining a function</li>
<li>that operates on any list of integers</li>
</ul></li>
</ul>

<p>Here&rsquo;s a basic formula:</p>

<ol>
<li>Identify duplicate code</li>
<li>Extract the duplicate code into the body of the function and specify the
inputs and return values of that code in the function signature</li>
<li>Update the two instances of duplicated code to call the function instead</li>
</ol>

<p>We can use this same process with generics. Just like a function can operate on
&ldquo;any list&rdquo;, generics allow code to operate on abstract types——like operating on
a slice of <code>i32</code> or a slice of <code>char</code> values.</p>

<h3>Generic Data Types</h3>

<p>The basic syntax for a function is:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>fn largest&lt;t&gt;(list: &amp;[T]) -&gt; &amp;T {}
</span></span></code></pre>
<p>You could also create struct using generics. For instance a <code>Point</code> struct
where x and y were either ints or floats.</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>struct Point&lt;T&gt; {...
</span></span></code></pre>
<p>or, if x is a different type from y:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>struct Point&lt;T, U&gt; {...
</span></span></code></pre>
<h2>Traits</h2>

<p>Traits define functionality a particular type has and can share with other
types. They are similar to the concept of <code>interfaces</code> in other languages.</p>

<h2>Lifetimes</h2>

<p>Lifetimes are another kind of generic. They ensure that references are valid as
long as we need them to be.</p>

<p>Every reference in rust has a lifetime. Most of the time they are implicit and
inferred. However there are times when rust explicitly needs you to annotate
them. For example:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>fn main() {
</span></span><span style="display:flex;"><span>    let r;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        let x = 5;
</span></span><span style="display:flex;"><span>        r = &amp;x;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(&#34;r: {}&#34;, r);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<p>This code won&rsquo;t compile because:</p>

<ul>
<li>we set the value of r as a reference to x</li>
<li>but by the time we try to use r, x has gone out of scope (it&rsquo;s memory was
deallocated)</li>
</ul>

<h3>The Borrow Checker</h3>

<p>The borrow checker compares scopes to determine whether all borrows are
valid. Take this code for example:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</span></span><span style="display:flex;"><span>    if x.len() &gt; y.len() {
</span></span><span style="display:flex;"><span>        x
</span></span><span style="display:flex;"><span>    } else {
</span></span><span style="display:flex;"><span>        y
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<p>This will give us a lifetime error. Which variable (x or y) will be returned?
Which variable needs to live longer? We don&rsquo;t know if the <code>if</code> or <code>else</code> block
will be executed. So we&rsquo;ll apply a generic lifetime that could handle either.</p>

<p>Here&rsquo;s how we&rsquo;d annotate the above function:</p>

<p>What this says is, &ldquo;the returned reference will be valid as long as both the
parameters are valid.&rdquo; Lifetime annotations don&rsquo;t change the length of
lifetimes; they just describe the relationships.</p>

<p>We&rsquo;re specifying that the borrow checker should reject any values that don&rsquo;t
adhere to these constraints. They go into the function signature because they
are part of the &ldquo;contract&rdquo; established.</p>

<blockquote>
<p>Ultimately, lifetime syntax is about connecting the lifetimes of various
parameters and return values of functions.</p>
</blockquote>

<p>All in all, lifetimes prevent dangling references.</p>

<h2>Testing</h2>

<p>Correctness is important, and the type system shoulders a large part of the
burden in proving it, but it can&rsquo;t do it all.</p>

<h3>Basic Test Flow</h3>

<ol>
<li>Set up any needed data or state</li>
<li>Run the code you want to test</li>
<li>Assert the results are what you expect</li>
</ol>

<p>This line: <code>use super::*;</code> means &ldquo;make anything we define in the outer module
available to this tests module.</p>

<h3>Test Organization</h3>

<p>There are two broad categories of tests:</p>

<ol>
<li>Unit (one module at a time)</li>
<li>Integration (external, the same as any user (or other code) would)</li>
</ol>

<p><code>#[cfg(test)]</code> —— only compile and run this code with <code>cargo test</code></p>

<p>Rust does allow you to test private functions.</p>

<blockquote>
<p>tests are just rust code, and the tests module is just another module</p>
</blockquote>

<p>Integration tests can only call functions that are part of your library&rsquo;s
public API. These kind of tests go here:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>adder
</span></span><span style="display:flex;"><span>├── Cargo.lock
</span></span><span style="display:flex;"><span>├── Cargo.toml
</span></span><span style="display:flex;"><span>├── src
</span></span><span style="display:flex;"><span>│   └── lib.rs
</span></span><span style="display:flex;"><span>└── tests
</span></span><span style="display:flex;"><span>    └── integration_test.rs
</span></span></code></pre>
<p>You can add more than one file in this dir, and it&rsquo;s good practice to group
tests together by the functionality they cover.</p>

<h2>Iterators</h2>

<p>In the iterator pattern, the iterator is responsible for the logic of
iterating over each item and determining when the sequence has
finished.</p>

<p>In Rust, iterators are lazy, meaning they have no effect until you
call methods that consume the iterator to use it up.</p>

<p>Say we have a vector:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>let v1 = vec![1, 2, 3];
</span></span></code></pre>
<p>Now we can create an iterator like this:</p>
<pre tabindex="0" style="color:#ebdbb2;background-color:#282828;"><code><span style="display:flex;"><span>let v1_iter = v1.iter();
</span></span></code></pre>
<p>This doesn&rsquo;t do anything yet; we&rsquo;re just storing the iterator in the
variable <code>v1_iter</code></p>

<blockquote>
<p>when you use a for loop, under the hood you&rsquo;re creating and
consuming an iterator</p>
</blockquote>

<p>In C and JavaScript you need to explicitly start a variable at index
0 and increment that variable to get values from a vector. Iterators
do this for you.</p>

<p>Iterator adaptors are methods defined on the iterator trait that don&rsquo;t
consume the iterator, but instead produce different iterators by
changing some aspect of the original iterator. <code>map()</code> is one example.
The <code>map()</code> method returns a new iterator that produces modified
items.</p>

<blockquote>
<p>map() takes a closure;
so does filter()</p>
</blockquote>

<p>In our minigrep I/O project, we were able to use an iterator to avoid
having to check the length of the args (the iterator handles that for
us).</p>

<p>We were also able to change our <code>search()</code> function. Instead of an
intermediate, mutable state variable, we could handle it in a more
functional style.</p>

<p>Most Rust programmers gravitate towards using iterators over loops.
Then instead of fiddling with lower-level looping mechanics, you can
focus on the high-level objective of the loop.</p>

<blockquote>
<p>iterators get compiled down to the same low level code that loops do
so performance is comparable</p>
</blockquote>

<h2>Smart Pointers</h2>

<p>References are the most basic type of pointer. Smart pointers add more
functionality.</p>

<ul>
<li>References only borrow data</li>
<li>Smart pointers own the data they point to</li>
</ul>

<h3>Cons List</h3>

<p>This is a recursive data type. It&rsquo;s a data structure that comes from
Lisp, and it&rsquo;s made up of nested pairs. It&rsquo;s Lisp&rsquo;s version of a
linked list (pairs of pairs).</p>

<h3>Interior Mutability</h3>

<p>This takes advantage of unsafe Rust. Unsafe code is code that&rsquo;s
manually checked rather than relying on the compiler to do it.</p>

<h2>Is Rust OOP?</h2>

<p>In OOP, an object is something that bundles data, and methods that act
on that data into a single entity. In this sense yes, rust is oop:</p>

<ul>
<li>structs and enums have data</li>
<li>impl blocks provide methods on structs and enums</li>
</ul>

<p>Encapsulation is another key idea in OOP——hiding the implementation
details and forcing interaction via public API. Rust offers this
through the use of <code>pub</code>. Everything else is private by default.</p>

<p>Inheritance as a Type System (interesting!) —— Rust doesn&rsquo;t provide
inheritance; a struct can&rsquo;t inherit from another struct.</p>

<p>Polymorphism —— you can substitute multiple objects for each other at
runtime if they share certain characteristics. Or&hellip; &ldquo;code that can
work with data of multiple types.&rdquo;</p>

<p>We can use trait objects to implement polymorphism in Rust instead of
inheritance. The specific purpose of traits is to allow abstraction
across common behavior.</p>

<h2>Fearles Concurrency</h2>

<p>Concurrent programming is where different parts of a program execute
independently.</p>

<p>Parallel programming is where different parts of a program execute at
the same time.</p>

<p>Ownership and type systems are tools that Rust uses to manage both
memory safety and concurrency problems.</p>

<p>Message-passing concurrency is where channels send messages between
threads.</p>

<p>Shared-state concurrency is where multiple threads have access to some
piece of data.</p>

<h3>Using Threads to Run Code Simultaneously</h3>

<p>In most operating systems, an executed program&rsquo;s code is run in a
process. The OS manages multiple processes at once.</p>

<p>Within a single program, you can also have independent parts that run
simultaneously. The features that run these intependent parts are
called threads.</p>

<blockquote>
<p>Example: A web server could have multiple threads so it could
respond to more than one request at a time.</p>
</blockquote>

<p>Rust uses a 1:1 model of thread implementation. In this model, a
program uses one OS thread per one language thread.</p>

<p>When using the main thread along with spawned threads, all spawned
threads are shut down when the main thread completes. To ensure all
spawned threads complete, we can save the return value of the spawned
thread in a variable, and call the <code>.join()</code> method at the end. This
will make sure all spawned threads finish befor main exits.</p>

<p>Calling <code>.join()</code> blocks the thread currently running until the thread
represented by the handle terminates.</p>

<h3>move</h3>

<p>There&rsquo;s a closure passed into thread::spawn, and if we want our
spawned thread to use any data from our main thread we need that
closure to capture the values it needs.</p>

<p>By adding the <code>move</code> keyword to our closure, we force the closure to
take ownership of the values it&rsquo;s using.</p>

<h3>Message Passing</h3>

<p>Message passing is used to ensure safe concurrency. Here&rsquo;s a slogan
from the Go language:</p>

<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by
communicating</p>
</blockquote>

<p>To accomplish message-passing, Rust provides an implementation of
channels. A channel is a general programming concept by which data is
sent from one thread to another.</p>

<p>Think of a channel like a stream or a river. Put a rubber duck in it
and it&rsquo;ll travel downstream to the end of the river.</p>

<p>A channel has two parts:</p>

<ul>
<li>transmitter (upstream)</li>
<li>receiver (downstream)</li>
</ul>

<p>One part of your code calls methods on the transmitter to send data,
and another part checks the receiving end for arriving messages.</p>

<p>Use <code>mpsc</code> to use channels. It stand for:</p>

<blockquote>
<p>multiple producer, single consumer</p>
</blockquote>

<h3>Shared-State Concurrency</h3>

<p>Message passing isn&rsquo;t the only game in town. You can also achieve
concurrency through multiple threads accessing the same shared data.</p>

<p>This is blowing off the first part of the Go slogan:</p>

<blockquote>
<p>do not communicate by sharing memory&hellip;</p>
</blockquote>

<p>Rust allows this, and a mutex is one of the more common concurrency
primitives for shared memory.</p>

<blockquote>
<p>This is in SICP!!!</p>
</blockquote>

<p>Mutex stands for &ldquo;mutual exclusion&rdquo;</p>

<p>The way it works is it allows only one thread to access some data at
any given time. It does this through a lock.</p>

<p>Mutexes are tricky to get right (which is why people love channels).
But Rust&rsquo;s type system and ownership rules make it so you can&rsquo;t get
them wrong!</p>

<p>When you put an i32 in a mutex, you must use <code>.lock()</code> to access the
i32 inside. The mutex will prevent you from accessing it otherwise.</p>

<p>Mutexes return smart pointers so you need to dereference them.</p>

<p>If you try to use a mutex with multiple threads you&rsquo;ll need to enable
multiple ownership using Arc<T>. It&rsquo;s like the type Rc<T> but the A
stands for atomic. It&rsquo;s an atomically reference counted type. They are
safe to share across threads.</p>

<h2>Patterns and Matching</h2>

<p>The program matches values against the patterns to determine whether
it has the correct shape of the data to continue running a particular
piece of code.</p>

<p>Overall, match expressions are very useful in distinguishing between
different kinds of data.</p>

<p>The compiler checks match expressions and makes sure they cover every
possible case——this isn&rsquo;t the case with <code>if let</code> expressions, and it&rsquo;s
an advantage to using <code>match</code>.</p>

<h3>Refutability</h3>

<p>Patterns come in two forms:</p>

<ul>
<li>refutable: patterns that can fail to match some possible value</li>
<li>irrefutable: patterns that will match for any possible value</li>
</ul>

        </div>
    </article>

    
    <div class="mt-16 p-4">
        <div class="container mx-auto flex flex-col md:flex-row md:justify-between">
            
            <div>
                <p>© 2024 Nathan Kawaller</p>
                <p>All code <a href=" https://raw.githubusercontent.com/git/git-scm.com/main/MIT-LICENSE.txt">MIT
                        licensed</a></p>
                
            </div>

            
            <div>
                
                <p><a href="https://www.instagram.com/vscode.shortcuts/?hl=en">Instagram</a></p>
                <a href="https://www.linkedin.com/in/nkawaller/">LinkedIn</a>
            </div>

            
            <div>
                
                <p>
                    Washington D.C. <span id='current-time'><span>
                </p>
                <p><a href="/korean-root.html">한국어</a></p>
            </div>
        </div>
    </div>
</body>

<script>
    
    function updateTime() {
        var currentTime = new Date();
        var hours = currentTime.getHours();
        var minutes = currentTime.getMinutes();
        var seconds = currentTime.getSeconds();

        
        minutes = (minutes < 10 ? '0' : '') + minutes;
        seconds = (seconds < 10 ? '0' : '') + seconds;

        var formattedTime = hours + ":" + minutes + ":" + seconds;
        document.getElementById("current-time").textContent = formattedTime;
    }

    
    setInterval(updateTime, 1000);

    
    updateTime();
</script>

</html>
